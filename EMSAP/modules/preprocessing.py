import csv
from collections import defaultdict
from Bio import SeqIO, AlignIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Align.Applications import MafftCommandline

def load_manifest(manifest_path):
    """
    Reads a manifest CSV file and returns a dictionary:
    {
        fasta_file_path_1: [id1, id2],
        fasta_file_path_2: [id3, id4]
    }
    """
    manifest_data = defaultdict(list)

    with open(manifest_path, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            manifest_data[row["fasta_file_path"]].append(row["id"])

    return manifest_data

def align_sequences(
    fasta_ref_AA,            # nucleotids reference
    fasta_ref_protein,       # aminoacids reference
    manifest_data,           # user-provided sequences
    trim_seq                 # output file with trimmed sequences
):
    """
    This function detects whether the input sequences are DNA or protein,
    selects the appropriate protein reference, aligns all sequences using MAFFT, identifies the ungapped region of the
    reference in the alignment, and trims all user sequences to match that
    region while preserving gaps.
    """

    # Select the appropriate reference based on sequence type
    fasta_ref = fasta_ref_protein        # use protein reference

    # Create combined FASTA for alignment
    to_align = "/content/to_align.fasta"     # temporary MAFFT input file
    aligned = "/content/align.fasta"         # MAFFT output file

    # join reference + user sequences into a single FASTA
    records = list(SeqIO.parse(fasta_ref, "fasta"))

    for fasta_path, ids in manifest_data.items():
        for record in SeqIO.parse(fasta_path, "fasta"):
            if record.id in ids:
                records.append(record)

    SeqIO.write(records, to_align, "fasta")  # write combined FASTA

    # Run MAFFT to generate alignment
    mafft_cline = MafftCommandline(input=to_align)  # default MAFFT command
    stdout, stderr = mafft_cline()                  # execute MAFFT and capture output

    with open(aligned, "w") as handle:
        handle.write(stdout)                        # save alignment to disk

    alignment = AlignIO.read(aligned, "fasta")      # load alignment into memory

    # Find the reference sequence inside the alignment
    ref_id = next(SeqIO.parse(fasta_ref, "fasta")).id   # ID of the original reference

    aligned_ref_seq = None
    for reg in alignment:                               # traverse aligned sequences
        if reg.id == ref_id:                            # identify reference inside alignment
            aligned_ref_seq = str(reg.seq)
            break

    if aligned_ref_seq is None:
        raise ValueError("Reference sequence not found in alignment!")  # if missing, raise error

    # Determine beginning and end of the reference (ignoring gaps)
    start_pos = next(i for i, aa in enumerate(aligned_ref_seq) if aa != "-")  # first non-gap
    end_pos = len(aligned_ref_seq) - next(i for i, aa in enumerate(reversed(aligned_ref_seq)) if aa != "-")  # last non-gap

    # positions in the aligned protein
    start_pos_protein = start_pos
    end_pos_protein = end_pos

    # Trim each sequence based on the reference interval
    trimmed_seqs = []
    for reg in alignment:
        if reg.id == ref_id:                       # skip reference in output
            continue

        seq_segment = str(reg.seq[start_pos:end_pos])  # cut segment while preserving gaps
        new_record = SeqRecord(Seq(seq_segment), id=reg.id, description=reg.description)
        trimmed_seqs.append(new_record)                # add trimmed sequence

    SeqIO.write(trimmed_seqs, trim_seq, "fasta")       # save trimmed sequences

    return start_pos_protein, end_pos_protein          # return informative positions

from Bio import SeqIO

def cut_protein_by_position_manifest(manifest_data, output_fasta, output_txt, pos_inicial, pos_final):
    """
    This function processes protein sequences listed in a MANIFEST file.

    It expects a dictionary generated by load_manifest(), structured as:
        {
            "path/to/fasta1.fasta": [id1, id2],
            "path/to/fasta2.fasta": [id3]
        }

    For each FASTA file:
      - Only sequences whose IDs are listed in the MANIFEST are processed.
      - The sequence is cut from pos_inicial to pos_final (1-based positions).
      - Sequences containing invalid amino acids (B, J, O, U, X, Z) are discarded.
      - Deletions ("-") inside the selected region trigger a warning.
    
    """

    invalid_aa = set(['B', 'J', 'O', 'U', 'X', 'Z'])

    with open(output_fasta, "a") as fasta_out, open(output_txt, "a") as txt_out:

        for fasta_path, ids_list in manifest_data.items():

            for record in SeqIO.parse(fasta_path, "fasta"):

                if record.id not in ids_list:
                    continue

                sequencename = record.description.split()[0]
                seq_str = str(record.seq).upper()

                # Ajuste de índice (Python começa em 0)
                cut_protein = seq_str[pos_inicial - 1 : pos_final]

                # Verifica deleções
                deletions_in_region = cut_protein.count("-")
                if deletions_in_region > 0:
                    print(
                        f"\033[93m\n⚠️ {record.id} ({sequencename}) has "
                        f"{deletions_in_region} deletion(s) in the selected region.\n\033[0m"
                    )

                # Verifica aminoácidos inválidos
                found_invalid = [aa for aa in cut_protein if aa in invalid_aa]
                if found_invalid:
                    letters_str = ", ".join(sorted(set(found_invalid)))
                    print(
                        f"\033[91m\n❌ {record.id} removed: "
                        f"inconsistent amino acids found ({letters_str})\n\033[0m"
                    )
                    continue

                region_label = f"{pos_inicial}-{pos_final}"

                fasta_out.write(f">{record.description}\n{cut_protein}\n")
                txt_out.write(f"{record.id}\npositions: {region_label}\n\n")

def clear_ambiguous_amino_acids(manifest_csv, fasta_input, fasta_output):

    """
    Cleans protein sequences in a FASTA file by removing ambiguous amino acids (B, J, O, U, X, Z) from sequences whose IDs are listed in a manifest CSV file.

    Parameters:
        manifest_csv (str): Path to the CSV file containing sequence IDs (column name: 'id').
        fasta_input (str): Path to the input FASTA file.
        fasta_output (str): Path where the cleaned FASTA file will be saved.

    """

    invalid_amino_acids = {'B', 'J', 'O', 'U', 'X', 'Z'}

    # Read IDs from the manifest
    manifest_ids = set()
    with open(manifest_csv, newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            manifest_ids.add(row['id'])

    cleaned_records = []

    for record in SeqIO.parse(fasta_input, "fasta"):
        seq_id = record.id
        sequence_str = str(record.seq).upper()

        if seq_id in manifest_ids:
            cleaned_sequence = "".join(
                aa for aa in sequence_str if aa not in invalid_amino_acids
            )

            if len(cleaned_sequence) != len(sequence_str):
                removed = len(sequence_str) - len(cleaned_sequence)

            record.seq = Seq(cleaned_sequence)

        cleaned_records.append(record)

    SeqIO.write(cleaned_records, fasta_output, "fasta")